Implement Two-Tier Proposals in EntityMachine

Add a proposal object/queue rather than applying transactions immediately.
Only finalize (execute) proposals once threshold signatures are reached.
Add Aggregated Signature Flow

Expand from individual secp256k1 signatures to a single combined/aggregated signature object.
Store partial signatures and merge them into one final signature for outgoing transactions or blocks.
Refine Event-Driven Architecture

Replace direct processCommand() calls with an event/message queue for each machine (“actor”).
Generate events (e.g., EVENT_OUTBOX) whenever a submachine updates state, and propagate them up/down the hierarchy.
Enhance Block Production on ServerMachine

Maintain a mempool (transaction inbox) and produce blocks at regular intervals (e.g., every 100ms).
Each block references the previous block hash, includes the signed transactions, and is stored in an on-disk or in-memory DB.
Synchronize Child Machine States

Ensure that Entity and Channel updates are stored/referenced in the ServerMachine’s state root or block hash (for a full hierarchical state proof).
Complete Dispute/Settlement Paths

Flesh out the ChannelMachine dispute logic to fully handle closing a channel on the parent chain (e.g., EntityMachine), applying final balances, and reflecting that in the global state.
Security & Authorization

Replace mock cryptographic checks (e.g., in ChannelMachine) with real ECDSA or BLS signature verification.
Optionally store private keys securely for SignerMachine rather than deriving from a hashed public key.
Improve Networking Protocol

Add specialized P2P messages for block/state requests and responses (e.g., REQUEST_BLOCK, RESPONSE_BLOCK).
Implement node discovery and peer liveness checks (beyond the current PING/PONG).




# Initial Prototype Plan

## Phase 1: Core Machine Types [ ]
- [ ] Define base Machine interface with core message handling
- [ ] Design Server machine type (root level)
- [ ] Design Signer machine type (identity level)
- [ ] Design Entity machine type (application level)
- [ ] Design Channel machine type (communication level)
- [ ] Implement basic state management for each machine type
- [ ] Define message types and routing between machines

## Phase 2: Server Implementation [ ]
- [ ] Basic server setup with WebSocket support
- [ ] In-memory state machine implementation
- [ ] Message aggregation and processing cycle (100ms)
- [ ] Inter-server communication via WebSocket
- [ ] Basic message routing between machines

## Phase 3: Basic Functionality [ ]
- [ ] Server-to-server message passing
- [ ] State updates propagation
- [ ] Simple client connection handling
- [ ] Basic error handling and logging

## Future Enhancements (Not in Initial Prototype)
- Blockchain state persistence
- DAO support
- Multi-key consensus mechanisms
- Complex state validation
- Merkle tree state verification
- LevelDB storage implementation

## Technical Notes

### Server Processing Cycle
- Aggregate incoming messages (100ms intervals)
- Update in-memory state
- Propagate updates to connected servers
- Route messages to appropriate machines

### Message Flow
- WebSocket connections between servers
- Client-server communication
- Machine-to-machine message routing

### State Management
- In-memory state for prototype
- Simple state updates without blockchain validation
- Direct message passing between machines

# Core Components

## Depository 
The smart contract that manages reserves, channels, and disputes.

## Server
- Root machine initially created for each user (personal unique machine)
- Processing cycle (every 100ms):
  - Aggregates incoming requests/messages 
  - Forms block with transaction map
  - Sends block/map to signers for signature
  - Waits for finalized blocks from all signers
  - Aggregates blocks into Merkle tree
  - Updates state and finalizes block
  - Forms messages for other servers
  - Distributes messages to other servers

## Signer
- Encapsulates entities associated with a specific private key
- Stores private key in root machine for transaction signing
- Receives and routes messages between signers and entities
- Acts as parent/super-machine for entities
- Handles entity-level consensus:
  - Can be automatic with single signer as proposer/validator
  - Or participates in DAO as proposer/validator/observer

## Entity
- Account abstraction that can represent:
  - Personal wallets
  - Company wallets (DAOs)
  - Payment hubs/exchanges
  - Decentralized applications
- All management through proposal mechanism
- Governed by quorum of signers

## Channel
- Abstraction for entity-to-entity message transmission
- Machine replicated in both entities
- Functions as bilateral account

## Technical Implementation

### Mempool Building (Server Level)
- Handles requests:
  - Directed to sub-machines (signers)
  - Server machine context execution
- Structure:
  - Uses Ethereum RLP encoding
  - Contains bytes32 keys and values array
  - Example: 5 keys, 7 values
    - First 5 for sub-machines
    - Last 2 for machine-level transactions

### Block Structure
- Previous block reference
- Mempool (long buffer string)
- State hash (sub-machines + machine state)
- Storage:
  - Blocks in LevelDB under block hash
  - Root machine state under server ID (0)

### Message Flow
- Input channels:
  - WebSocket from user wallet (token auth)
  - Entity-directed messages
- Server aggregation of external messages

### Transaction Processing
- Server as message entry point
- 100ms processing cycle:
  - Message aggregation
  - Block/transaction map formation
  - Sub-machine distribution
  - Parallel processing (Promise.all)
  - Machine-level transaction handling

### Security Model
- Initial focus on core functionality
- Entity-level signatures
- API token authentication
- Hierarchical access control by machine level