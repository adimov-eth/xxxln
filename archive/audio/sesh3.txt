{"text":"Алло, как слышно? Всё, пишет. Итак, как мы обсудили, на чём остановились и какой код сгенерировался. Это то, что запускается сервер, он процессит какого-то рода транзакции, которые либо идут в своих детей, либо на его же уровне исполняются. Это сейчас не суть, иерархия нас не важна. Нас волнует. По сути, всё сводится к одной проблеме. Сервер при запуске считывает из LevelDB своё состояние, и считывает он его разными способами. Чтобы ему прийти в своё актуальное состояние, это надо читать последний снапшот и заплать к нему все блоки с этого момента, которые произошли после снапшота. Соответственно, при самый минимальный viable prototype, снапшотов не существует. Они как бы сначала создаются из воздуха, базовое состояние, а плавятся все транзакции. Но следующим же апгрейдом, что можно сразу вписать, это два вида снапшотов, которые будут происходить. И мьютабл, и мьютабл снапшот. То есть, изменяем мы, не изменяем. Понимаешь разницу? Тот, который будет мьютабл... Алло? Слышно? Тот, который будет мьютабл, он... Всё зависит от того, в какие ключи он пишет в LevelDB, по сути. То есть, мьютабл пишет в ключи, где идёт ID всех этих машин друг за другом. И, соответственно, ты можешь прочитать моментально их сразу, и сразу построить с одного батча LevelDB-запроса весь свой memory state. Мы же оперируем только с JSON-объектом в памяти. То есть, LevelDB — это способ хранения, а работа вся идёт с памятью. Как мы договорились, даже хаб может позволить себе 100 гигабайт памяти и держать 10 миллионов каналов. То есть, можно, в принципе, забить вообще на синхронизацию памяти и storage. Делать это просто полную загрузку при начале. То есть, ты запускаешь приложуху, у тебя сразу батчем всё, что есть в LevelDB, скачивается в память. И из этого констрактится объект сервера, сайнеров и так далее. Просто циклом. Так вот, мьютабл хранит по ключам самого значения. То есть, ID-шка первой машины, ID-шка субмашины и так далее. И там какие-то могут быть, например, точка property. Потому что все данные надо будет в итоге, в конечном счёте, разбивать на кусочки. Потому что LevelDB не сможет сжать 100 килобайт в одну запись на каждое изменение рута машины. Просто вначале мы делаем это компактным. Всё inline. То есть, транзакции inline-блока. То есть, даже не выносим их в отдельную LevelDB-вертекс, так сказать, графа. Это же всё, по сути, данные хранятся в DAG. Так вот, у нас два способа хранения основных снапшотов — и мьютабл, и мьютабл. Мьютабл, как я сказал, это тот способ, который позволяет вообще сразу загрузиться на последний стейт. То есть, ты каждое сохранение блока, ты сливаешь весь свой снапшот — мьютабл. Точнее, даже не обязательно на каждое сохранение блоков. Ты можешь это делать каждые 100 блоков, например. То есть, по дефолту сохранять только блоки без снапшотов. И потом, если у тебя до 100 блоков, ты просто загружаешь последний снапшот, мьютабл который. И из него получаешь актуальное текущее состояние в памяти, которое было на запуск выключения. Чё ж такое? Слышно? Алло? А мьютабл способ — это когда мы сохраняем не по ключу, а по хэшу, значение которое сохраняем, так как работает Merkle DAG в IPFS. То есть, таким образом мы не можем даже в будущем перезаписать этот снапшот. Таким образом он остается в архиве навсегда. И из него легко будет потом создавать симуляции, прочитав в будущем и воссоздав исторические состояния даже много дней в прошлом. Полностью прочитав состояние системы в тот момент, то есть сервера."}%