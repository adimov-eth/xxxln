# Initial Prototype Plan

## Phase 1: Core Machine Types [✓]
- [✓] Define base Machine interface with core message handling
- [✓] Design Server machine type (root level)
- [✓] Design Signer machine type (identity level)
- [✓] Design Entity machine type (application level)
- [✓] Implement Entity machine
- [✓] Design Channel machine type (communication level)
- [✓] Implement basic state management for each machine type
- [✓] Define message types and routing between machines

## Phase 2: Server Implementation [⚡]
- [✓] Basic server setup with WebSocket support
- [✓] In-memory state machine implementation
- [✓] Message aggregation and processing cycle (100ms)
- [ ] Inter-server communication via WebSocket
- [ ] Basic message routing between machines

## Phase 3: Basic Functionality [⚡]
- [ ] Server-to-server message passing
- [ ] State updates propagation
- [ ] Simple client connection handling
- [✓] Basic error handling and logging

## Phase 4: Security & Validation [⚡]
- [✓] Implement cryptographic signing (secp256k1)
- [✓] Add transaction validation
- [✓] Add entity validation
- [✓] Implement batch signature verification
- [✓] Add signature aggregation for better performance
- [✓] Implement parallel signature verification
- [✓] Add support for multiple signature schemes

## Phase 5: State Management [⚡]
- [ ] Implement state versioning
- [ ] Add state transition validation
- [ ] Implement state rollback mechanism
- [ ] Add state snapshot functionality
- [ ] Implement state pruning

## Future Enhancements (Not in Initial Prototype)
- Blockchain state persistence
- DAO support
- Multi-key consensus mechanisms
- Complex state validation
- Merkle tree state verification
- LevelDB storage implementation

## Technical Notes

### Server Processing Cycle
- Aggregate incoming messages (100ms intervals)
- Update in-memory state
- Propagate updates to connected servers
- Route messages to appropriate machines

### Message Flow
- WebSocket connections between servers
- Client-server communication
- Machine-to-machine message routing

### State Management
- In-memory state for prototype
- Simple state updates without blockchain validation
- Direct message passing between machines

# Core Components

## Depository 
The smart contract that manages reserves, channels, and disputes.

## Server [⚡]
- [✓] Root machine initially created for each user (personal unique machine)
- [✓] Processing cycle (every 100ms)
- [✓] Message aggregation
- [✓] Block/transaction map formation
- [ ] Signature collection
- [ ] Block finalization
- [ ] State updates
- [ ] Message distribution

## Signer [✓]
- [✓] Encapsulates entities associated with a specific private key
- [✓] Transaction signing with secp256k1
- [✓] Batch signature verification
- [✓] Entity validation
- [✓] Transaction validation
- [✓] State management
- [✓] Message routing

## Entity [✓]
- [✓] Account abstraction
- [✓] Multi-signature support
- [✓] Threshold signature validation
- [✓] Entity machine implementation
- [✓] Proposal mechanism
- [✓] State management
- [✓] Message handling
- [ ] DAO governance (future)

## Channel [⚡]
- [✓] Entity-to-entity message transmission
- [✓] Bilateral account management
- [✓] Basic state synchronization
- [ ] Enhanced dispute resolution
  - [ ] State tracking
  - [ ] Timeout handling
  - [ ] Evidence validation
  - [ ] History tracking
- [ ] State verification
  - [ ] Hash computation
  - [ ] Signature verification
  - [ ] Replay protection
  - [ ] State merkleization
- [ ] Channel lifecycle
  - [ ] Closing mechanism
  - [ ] Settlement finalization
  - [ ] Force-close handling
- [ ] Multi-hop payments
  - [ ] HTLC support
  - [ ] Payment routing
  - [ ] Timelock mechanisms

## Technical Implementation

### Mempool Building (Server Level)
- [✓] Request handling
- [✓] Sub-machine routing
- [✓] Transaction encoding
- [ ] Block formation

### Block Structure
- [ ] Previous block reference
- [ ] Mempool encoding
- [ ] State hash computation
- [ ] Storage implementation

### Message Flow
- [✓] Input channel definition
- [ ] WebSocket implementation
- [ ] Entity message routing
- [ ] Server message aggregation

### Transaction Processing
- [✓] Server entry point
- [✓] Processing cycle
- [✓] Message aggregation
- [✓] Transaction validation
- [ ] Parallel processing
- [ ] Machine-level transactions

### Security Model
- [✓] Entity-level signatures
- [✓] Cryptographic validation
- [ ] API token authentication
- [ ] Hierarchical access control

## Next Steps Priority
1. Complete Channel dispute resolution
   - State tracking
   - Timeout handling
   - Evidence validation
   - History tracking
2. Implement Channel state verification
   - Hash computation
   - Signature verification
   - Replay protection
   - State merkleization
3. Add Channel lifecycle management
   - Closing mechanism
   - Settlement finalization
   - Force-close handling
4. Develop multi-hop payments
   - HTLC implementation
   - Payment routing
   - Timelock mechanisms
5. Add WebSocket communication layer
