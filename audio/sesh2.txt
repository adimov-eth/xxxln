{"text":"Поехали, как билдится mempool на уровне сервера. Короче, как билдится mempool на уровне сервера машины. Он получает на вход запросы, которые направляются либо к саб-машинам, либо выполняются в контексте самой машины-сервера, как и дальнейшие все в иерархии. Итак, mempool представляет собой закодированные в rlp эфира значения из набора ключей по bytes32 массива, и далее следует массив значений, которые по этим ключам надо передавать. Например, если 5 ключей и 7 значений, то первые 5 значений направляются в следующие под-машины, в данном случае в сайнеры, а последние 2 являются транзакциями, которые выполняются в контексте этой же машины, то есть транзакциями уровня машины. Например, создание нового сайнера. Итак, наша задача сделать сначала с транзакциями на уровне самой машины, допустим, простой counter plus 1, единственные транзакции. То есть мы запускаем серверную машину и раз в 100 миллисекунд искусственно создаем транзакцию на помещение каунтера. И запуская timeout loop, пропозер луп, так называемый, для серверной машины, он раз в 100 миллисекунд создает этот блок с этим инкрементирующей транзакцией. Соответственно, структура блока это ссылка на предыдущий блок, набор вот этих транзакций в виде mempool, это одна долгая длинная буферная строка, и хэш стейта, который содержит контент всех субмашин и состояние самой машины. Соответственно, это все пишется в leveldb под номером блока, точнее под хэшом блока. И также сохраняется в руте машины. Рут машины хранится по ключу id сервера, в данном случае это просто 0 в leveldb, а значение это rlp закодированное состояние машины в виде последнего блока. А, кстати, в данном случае нет конца этого блока, тут просто сразу вот этот вот собственный блок. Последний финализованный блок и является рутом машины в данном случае. Окей, у нас есть сервер, он крутится, и как к нему приходят сообщения? Им же должно что-то приходить? Да, сообщения приходят по веб-сокету, но при симуляции можно просто симулировать создание тайм-аутов разных сообщений извне. Итак, сообщения могут приходить к серверу как от юзера через юзер-валет, через кошелек со специальным токеном, тогда они считаются авторизованными. Также он может получать сообщения, которые направлены в отдельных entities. У нас, смотри, пока не было сущности юзера, типа через валет оно приходит от энтики. Ну, мы сейчас на каунтере просто. Да, я понимаю, я понимаю, я просто... Сайнеры где появляются в этом месте? Сервер, сайнеры. Да. В сервер приходят извне все сообщения накапливаются, в сайнер приходят сообщения из юзера-валета, то есть ты сайнеру говоришь, я хочу... То есть, смотри, у нас есть сервер и я просто обычный юзер. Как я инициирую транзакцию, чтобы что-то поменялось в стрейте? Уже логики платежей или в каунтере? Да просто каунтер. Я хочу конденсировать глобальный каунтер. Каунтер делается уже у нас прямо в контексте самого приложения в джойскрипте, в этом индексном файле. Сервером? Да. Он просто считает блоки, ты этот каунтер говоришь? Не, я говорю транзакцию в виде каунтера, которая просто инкрементор. Да, окей, окей, окей. То есть мы реализуем одну, а в данном случае сам серверный файл, у нас же минимальный MVP. А в реальности все транзакции будут инстализированы либо через, соответственно, сам юзер-кошелек по токену, локальная HTML, которая в браузере общается с демоном этих серверов. А в реальности заведем на сервере мой личный каунтер. Я как юзер хочу инкомментировать на сервере мой каунтер. Ты имеешь в виду сайнерский каунтер? Да, просто прислать сообщение, сделай что-то. Тогда просто два уровня абстракции сразу сделать, и сервер, и сайнер. Ну, в принципе, я думаю, можно сразу как раз заложить. Нет, это следующий шаг. Да, это следующий шаг. По сути, каунтер можно теперь создавать в любой из уровней машин."}
     
{"text":"Таргетишь извне, когда ты сразу выбираешь, куда по уровню машины ты приходишь. И вот эта функция, которая либо WebSocket Server onReceiveMessage, либо мы вручную вызываем, она просто получает, кто мне послал, то есть кто другой сайнер, другой сервер, мы эту информацию знаем, и другой энтити, типа откуда оно изначально идет, и оно направлено тоже куда-то в моем сайнере, в моем сервере, в моем сайнере, и в одну из моих энтити. Это сообщение извне. Я, может, неправильно спросил, смотри, может быть так, я юзер обычный, и у меня есть кошель, я в кошельке, наверное, хочу увеличить инкрементный каунтер, просто типа... Вот, это уже следующий уровень, это энтити. Я, ну, типа, я, я как юзер, куда вхожу, типа, куда я отправляю сообщение, как юзер? Ты также присылаешь ее вот в этот WebSocket с таргетом, с роутом... Кому я присылаю? К серверу, к серверу, потому что в рут, на входящий всегда все входит через сервер, и дальше он распределяет этого на продюсер. Ага, понял. На остальные, на сайнеры, на энтити, на каналы. Ага. И потом все это собирает, promise all. Все, я понял, я как юзер, у меня просто есть какой-то приватный ключ, и я пошлю какой-то... Ну, токен, api токен, который ты просто, тебе сама консоль рисует, и она также в памяти хранится. То есть, ты, как юзер, можешь создавать сообщение уровня, как сервера, так и сайнера, более рут, рутовые, то есть, чем более старшая машина, тем больше у тебя контроль доступа над остальными, тем более приоритет на эту задачу можешь ставить. А внешние энтити, они могут взаимодействовать только с энтитис. Либо на этапе создания энтити они могут взаимодействовать с сайнерами. А, то есть, считается, что ты авторизованный юзер, и твоя авторизация, она не связана с приватными ключами? Да, там api токен, то есть, когда ты добавляешь свою транзакцию в mempool по api токену, то он сразу смотрит, можно ли тебе добавиться туда, в этой очереди, потому что очередь, вот этот mempool, она же иерархичная, то есть, там ключи для следующего уровня, их значение для следующего уровня, плюс значение, можно все это в одну просто строчку закинуть, ты понял, как я написал? Ключи, значение и значение для той же самой сущности, без ключа уже. И, соответственно, ты в real-time разбиваешь это rlpeh, и это простая функция, которая буферы либо энкодит, либо декодит, и ты вот по этим ключам все в сайнеры, вот эти значения promise all послал, а вот эти, в этот же момент, начинаешь процессить на себе, один за одной, вот нам задача даже сейчас игнорировать вот эти вот ключи значения, сделать только на уровне самой серверной машины, counter, плюс 5, плюс 6, плюс 7, и state просто прибавляет число, а state можно хранить в виде просто закодированного gsum, просто в этом буфере, или да, либо в rlpeh просто, как число, там, нулевой integer. Шаг ноль, мы просто делаем state в тупую, в лоб, без даже подписи, мы просто... А тут они не нужны, кстати, на уровне сервера подписи нет смысла делать, потому что подписывать тебе надо уровень выше, то есть, как минимум entity надо подписывать, а вот сайнер можно даже тоже не подписывать, потому что тебе что надо подписывать? Только в той ситуации, когда кто-то за тобой эти блоки будет проверять и исполнять, а сайнер, его как бы нет смысла реплицировать, для этого существуют entities, которые реплицируют. Короче, набираем вот эту эротичную структуру из примитивных штук, которые ничего не верифицируют, они просто... Первые два уровня, нет подписи практически. Не, я про то, что дальше добавляем, смотрим, добавляем подписи, там мне не нужны, дальше добавляем блоки. Да, подписи, это как бы security, навешать можно всегда потом, сейчас главное, чтобы все... Да, можно даже без подписи блоки сначала сделать. Вообще, все без подписи, все, забудь, что есть подписи, просто... Ага, понял, сначала блоки, потом подписи, и только потом подписи. Просто trust, что все, типа, правильно, скажем, вначале. Я все потом 10 раз проверю в список, что когда должно проверяться. Класс. Блин, самое красивое, что мне хочется больше всего закончить, тогда я скажу, типа, блядь, вот самая тяжелая часть пройдена, это вот агрегированная подпись, то есть хочется, чтобы в коде логики было вот как sign и verify, для обычного юзера это понятно, но в момент, типа, в той же сущности регенерировать. А когда у тебя 10 юзеров, и ты сейчас выполняешь от лица оператора, и тут, от лица пропозера, и тут ты как бы подписываешься, но ты подписываешь как будто не единственная подпись, а сразу в свой слот вот в этой агрегированной подписи даешь, и в pre-commit'ах ее тоже собираешь, и, соответственно, у тебя накапливается на все исходящие транзакции, на все хэши, которые ты там куда-то в депозитарии шлешь или дальше, либо генерируешь блоки для каналов, то есть это последний уровень виртуализации, то есть когда в институте что-то происходит, она решает, что-то сделать с каналами, ты параллельно с передачей блока и передаешь подписи, связанные с каналами, но они не хранятся внутри самого блока, потому что это бы создало двойной лук. Ты понимаешь, почему? Вот у тебя 10 юзеров, и тебе надо агрегироваться на какое-то изменение, вы уже решили, что вам надо делать платеж, ты посылаешь на 10, типа, я пропозжу такой-то блок, дайте мне ваши pre-commit'ы. Они возвращают pre-commit'ы и подписи на все исходящие"}
     
{"text":"в результате вот этого блока, они все проверили, транзакции, которые идут, собственно, в каналы, то есть создание блоков в каналах, они моментально, если у тебя статус ready в канале, потому что у тебя два статуса, может быть, в канале, ready, ты можешь сейчас послать send, ты уже послал блок, ты ждешь ответа, ты не можешь сейчас послать блок, то есть он дуплексный, он должен получить acknowledgement, как этот, SYN ACK, и, соответственно, у тебя набор хэшей, которые надо подписать, которые именно являются вот этими пропознами в каналах, которые были ready, еще надо учитывать, и их тоже надо подписать, соответственно, они вместе с pre-commit возвращают и подписи на вот эти вот все исходящие хэши, и у тебя сразу агрегируется там 10 сообщений, 10 каналов, например, и все они тоже сразу подписаны, потому что, если бы это не делать, только тогда бы надо было отдельно им посылать хэш, и еще один раунд было бы взаимодействия, это очень долго, а надо сразу оптимизировать это для, типа, прям быстрого хаба, то есть, по сути, может быть, вот так выглядит, пришел запрос на хаб из четырех дата-центров, он сразу послал на три остальных, вернули подписи, и с подписями на канальные сообщения следующие каналы, то есть это платеж, например, union, он дальше идет, и он сразу рассылает и вот этому бродкасту, и этому, после того, как он сделал батч в level.db, записался, и начал рассылать, и этим прилетают тоже серверные мемпулы, раз в 100 миллисекунд, хоп. Вот, и я вот в этом месте, я почему придумал яичных агентов, что нужно, чтобы все участники подписи групповой, что они были онлайн, ну, грубо говоря, ну, типа, финализация этих подписей должна происходить довольно быстро, вот, и прикольно, что в определенных случаях это не 100% кейсов, может быть, что у тебя есть просто и агент-бухгалтер, он такой, а, нормальная процедура, это пропускаем, типа. А вот сейчас, смотри, важное отличие заметить, мы говорили про подписи при коммите на блоке, но есть два вида, те транзакции, что попали в глоб, они автоматически все исполняются и выполняются, почему, потому что у нас уровень управления сущностей двухслойный, транзакции, что делают, работают с пропоузлами, и только когда пропоузл набрал достаточное количество действий, происходит реальное действие внутри энтити, почему, потому что если бы мы разрешили одной транзакции все менять, тогда бы любой из 100 владельцев этой энтити мог бы взять и изменить, удалить ее, например, поэтому любые важные изменения проходят через систему пропоузлов, когда кворум сайнеров этой энтити договорились о чем-то, и только когда у них, и тут, кстати, важно сделать очень красивую и компактную систему, где будет просто храниться хэш, и на нем просто расти число voting shares, и когда оно пресекает какой-то кворум, в конце этого блока делается просто execute пропоузл, которые финализованы, кстати, в коде он как раз что-то похожее написал, finalized, expired proposals, чтобы это было все удобно просто по объекту джейсона, и чтобы эти пропоузлы выполнялись, то есть уже выполнялись приватные методы этой машины, по сути, которые нельзя вызвать извне обычной транзакции, иначе бы это было просто компрометнировать сущность, то есть двухслойная система контроля изменений в состоянии машины. Так, ну все, наверное."}
     
